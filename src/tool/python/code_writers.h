#pragma once

namespace pywinrt
{
    template<typename F>
    void write_snake_case(writer& w, std::string_view const& name, F case_func)
    {
        XLANG_ASSERT(name.size() > 0);

        for (std::string_view::size_type i = 0; i < name.size(); i++)
        {
            if (isupper(name[i]) && i > 0)
            {
                static const std::set<std::string_view> casing_exceptions = { "UInt", "IPAddress" };

                auto sub = name.substr(i - 1);
                if (sub[0] != '_' && std::none_of(casing_exceptions.begin(), casing_exceptions.end(), 
                    [&sub](std::string_view v) { return sub.substr(0, v.length()) == v; }))
                {
                    w.write('_');
                }
            }

            w.write(case_func(name[i]));
        }
    }

    void write_upper_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::toupper(c)); });
    }

    void write_lower_snake_case(writer& w, std::string_view const& name)
    {
        write_snake_case(w, name, [](char c) { return static_cast<char>(::tolower(c)); });
    }

    void write_lower_case(writer& w, std::string_view const& ns)
    {
        for (auto c : ns)
        {
            w.write(static_cast<char>(::tolower(c)));
        }
    }

    void write_license(writer& w, std::string_view comment_marker = "//")
    {
        w.write("% WARNING: Please don't edit this file. It was generated by Python/WinRT v%\n\n", comment_marker, XLANG_VERSION_STRING);
    }

    void write_python_setup_filenames(writer& w, std::vector<std::string> const& namespaces)
    {
        XLANG_ASSERT(namespaces.size() > 0);

        for (auto&& ns : namespaces)
        {
            w.write("'%/src/py.%.cpp', ", settings.module, ns);
        }

        w.write("'%/src/_%.cpp'", settings.module, settings.module);
    }

    void write_python_import_type(writer& w, TypeDef const& type)
    {
        if (!is_exclusive_to(type))
        {
            w.write("@ = _ns_module.@\n", type.TypeName(), type.TypeName());
        }
    }

    void write_python_import_namespace(writer& w, std::string_view const& ns)
    {
        w.write("\ntry:\n    import %.%\nexcept:\n    pass\n", settings.module, bind<write_lower_case>(ns));
    }

    void write_python_enum(writer& w, TypeDef const& type)
    {
        w.write("\nclass %(enum.%):\n", type.TypeName(), is_flags_enum(type) ? "IntFlag" : "IntEnum");
        {
            writer::indent_guard g{ w };

            for (auto&& field : type.FieldList())
            {
                if (auto constant = field.Constant())
                {
                    w.write("% = %\n", bind<write_upper_snake_case>(field.Name()), *constant);
                }
            }
        }
    }

    void write_include(writer& w, std::string_view const& ns)
    {
        if (w.current_namespace != ns)
        {
            auto format = R"(
#if __has_include("py.%.h")
#include "py.%.h"
#endif
)";
            w.write(format, ns, ns);
        }
        else
        {
            w.write("#include \"py.%.h\"\n", ns);
        }
    }


    // All generated try/catch blocks go thru this function in order to have a single place
    // to change as we test the binary size of different approaches
    void write_try_catch(writer& w, std::function<void(writer&)> tryfunc, std::string_view exception_return_value = "nullptr")
    {
        w.write("try\n{\n");
        {
            writer::indent_guard g{ w };
            tryfunc(w);
        }
        w.write(R"(}
catch (...)
{
    py::to_PyErr();
    return %;
}
)", exception_return_value);
    }

    void write_setter_try_catch(writer& w, std::function<void(writer&)> tryfunc)
    {
        w.write(R"(if (arg == nullptr)
{
    PyErr_SetString(PyExc_TypeError, "property delete not supported");
    return -1;
}

)");
        write_try_catch(w, [&](writer& w) { tryfunc(w); }, "-1");
    }

    void write_template_arg_name(writer& w, GenericParam const& param)
    {
        w.write(param.Name());
    }

    void write_template_arg(writer& w, GenericParam const& param)
    {
        w.write("typename %", bind<write_template_arg_name>(param));
    }

    void write_type_namespace(writer& w, TypeDef const& type)
    {
        auto segments = get_dotted_name_segments(type.TypeNamespace());
        w.write("%", bind_list("::", segments));
    }

    void write_pywrapper_type(writer& w, TypeDef const& type)
    {
        w.write("py::wrapper::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyproj_type(writer& w, TypeDef const& type)
    {
        w.write("py::proj::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_pyimpl_type(writer& w, TypeDef const& type)
    {
        w.write("py::impl::%::@", bind<write_type_namespace>(type), type.TypeName());
    }

    void write_python_wrapper_template_type(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            write_pyproj_type(w, type);
        }
        else
        {
            w.write("%", type);
        }
    }

    void write_get_python_type_specialization(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        auto format = R"(template<>
struct winrt_type<%>
{
    static PyTypeObject* python_type;
    static PyTypeObject* get_python_type() { return python_type; }
};

)";
        w.write(format, bind<write_python_wrapper_template_type>(type));
    }

    void write_python_wrapper_type(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("winrt_wrapper");
            break;
        case category::interface_type:
            if (is_ptype(type))
                w.write("winrt_pinterface_wrapper");
            else
                w.write("winrt_wrapper");
            break;
        case category::struct_type:
            w.write("winrt_struct_wrapper");
            break;
        }
    }

    void write_python_wrapper_alias(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        w.write("using @ = py::%<%>;\n", type.TypeName(),
            bind<write_python_wrapper_type>(type),
            bind<write_python_wrapper_template_type>(type));
    }

    void write_type_base(writer& w, TypeDef const& type)
    {
        if (has_dealloc(type))
        {
            w.write("bases.get()");
        }
        else
        {
            w.write("nullptr");
        }
    }

    void write_ns_module_exec_init_python_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        w.write("py::winrt_type<%>::python_type = py::register_python_type(module, _type_name_@, &_type_spec_@, %);\n",
            bind<write_python_wrapper_template_type>(type),
            type.TypeName(),
            type.TypeName(),
            bind<write_type_base>(type));
    }

    void write_ns_module_exec_func(writer& w, cache::namespace_members const& members)
    {
        w.write("static int module_exec(PyObject* module) noexcept\n{\n");
        {
            writer::indent_guard g{ w };
            write_try_catch(w, [&](auto& w)
                {
                    w.write("py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::winrt_base>::python_type) };\n\n");
                    settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.classes)(w);
                    settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.interfaces)(w);
                    settings.filter.bind_each<write_ns_module_exec_init_python_type>(members.structs)(w);
                    w.write("\nreturn 0;\n");
                }, "-1");
        }

        w.write("}\n");
    }

    void write_ns_module_name(writer& w, std::string_view const& ns)
    {
        auto segments = get_dotted_name_segments(ns);
        w.write("_%_%", settings.module, bind_list("_", segments));
    }

    void write_namespace_initialization(writer& w, std::string_view const& ns, cache::namespace_members const& members)
    {
        w.write("\n// ----- % Initialization --------------------\n", ns);

        write_ns_module_exec_func(w, members);
        w.write(strings::ns_module_def, ns, bind<write_ns_module_name>(ns));
    }

    void write_namespace_module_init_function(writer& w, std::string_view const& ns)
    {
        auto format = R"(
PyMODINIT_FUNC
PyInit_% (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::%::module_def);
}
)";
        auto segments = get_dotted_name_segments(ns);
        w.write(format, bind<write_ns_module_name>(ns), bind_list("::", segments));
    }

    void write_winrt_type_specialization_storage(writer& w, TypeDef const& type)
    {
        if (!is_exclusive_to(type))
        {
            w.write("\nPyTypeObject* py::winrt_type<%>::python_type;", bind<write_python_wrapper_template_type>(type));
        }
    }

    void write_winrt_type_name_constant(writer& w, TypeDef const& type)
    {
        w.write("constexpr const char* const _type_name_@ = \"@\";\n", type.TypeName(), type.TypeName());
    }

    void write_dealloc_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        if (category == category::class_type && is_static_class(type))
        {
            return;
        }

        w.write("\nstatic void _dealloc_@(%* self)\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));

        if (category == category::class_type || category == category::interface_type)
        {
            writer::indent_guard g{ w };

            auto format = R"(auto hash_value = %;
py::wrapped_instance(hash_value, nullptr);
self->obj%;
)";

            w.write(format,
                is_ptype(type) ? "self->obj->hash()" : "std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj)",
                is_ptype(type) ? ".release()" : " = nullptr");
        }
        w.write("}\n");
    }

    void write_method_self_param(writer& w, TypeDef const& type, bool is_static)
    {
        if (is_static)
        {
            w.write("PyObject* /*unused*/");
        }
        else
        {
            w.write("%* self", bind<write_pywrapper_type>(type));
        }
    }

    void write_param_name(writer& w, method_signature::param_t param)
    {
        w.register_type_namespace(param.second->Type());
        w.write("param%", param.first.Sequence() - 1);
    }

    void write_out_param_init(writer& w, method_signature::param_t const& param)
    {
        call(get_type_semantics(param.second->Type()),
            [&](TypeDef const& type)
        {
            switch (get_category(type))
            {
            case category::class_type:
            case category::interface_type:
            case category::delegate_type:
                w.write("nullptr");
                break;
            }
        },
            [&](generic_type_instance const&) { w.write("nullptr"); },
            [](auto) {});
    }

    void write_convert_to_params(writer& w, MethodDef const& method, int sequence)
    {
        switch (get_argument_convention(method))
        {
        case argument_convention::single_arg:
            w.write("arg");
            break;
        case argument_convention::variable_args:
            w.write("args, %", sequence);
            break;
        default:
            throw_invalid("write_convert_to_params");
        }
    }

    void write_method_param_definition(writer& w, MethodDef const& method, method_signature::param_t const& param)
    {
        auto sequence = param.first.Sequence() - 1;

        switch (get_param_category(param))
        {
        case param_category::in:
            w.write("auto % = py::convert_to<%>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            break;
        case param_category::out:
            w.write("% % { % };\n", param.second->Type(), bind<write_param_name>(param), bind<write_out_param_init>(param));
            break;
        case param_category::pass_array:
            w.write("auto _% = py::convert_to<winrt::com_array<%>>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            w.write("auto % = winrt::array_view<const %>(_%.data(), _%.data() + _%.size());\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_param_name>(param),
                bind<write_param_name>(param));
            break;
        case param_category::fill_array:
            w.write("auto %_count = py::convert_to<winrt::com_array<%>::size_type>(%);\n",
                bind<write_param_name>(param),
                param.second->Type(),
                bind<write_convert_to_params>(method, sequence));
            w.write("winrt::com_array<%> % ( %_count, py::empty_instance<%>::get() );\n",
                param.second->Type(),
                bind<write_param_name>(param),
                bind<write_param_name>(param),
                param.second->Type());
            break;
        case param_category::receive_array:
            w.write("winrt::com_array<%> % { };\n",
                param.second->Type(),
                bind<write_param_name>(param));
            break;
        default:
            throw_invalid("invalid param_category");
        }
    }

    void write_method_invoke_context(writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (is_ptype(type))
        {
            w.write("_obj.");
        }
        else if (method && (is_static(method) || is_constructor(method)))
        {
            w.write("%::", type);
        }
        else
        {
            w.write("self->obj.");
        }
    }

    void write_method_cpp_name(writer& w, MethodDef const& method)
    {
        auto name = method.Name();

        if (method.SpecialName())
        {
            w.write(name.substr(name.find('_') + 1));
        }
        else
        {
            w.write(name);
        }
    }

    void write_detach_param(writer& w, std::string const& paramName)
    {
        w.write("%.detach()", paramName);
    }

    void write_py_tuple_pack(writer& w, std::vector<std::string> const& params)
    {
        w.write("PyTuple_Pack(%, %)", static_cast<int>(params.size()), bind_list<write_detach_param>(", ", params));
    }

    void write_method_body_contents(writer& w, TypeDef const& type, MethodDef const& method, bool put_property_method = false)
    {
        XLANG_ASSERT(!is_constructor(method));

        auto write_void_return = [](writer & w, MethodDef const& method, bool set_property_method)
        {
            // instance property set methods are projected as Python setters, thus return 0 to indicate success
            // static property set methods are projected as normal Python methods that return None
            if (set_property_method && !is_static(method))
            {
                w.write("return 0;\n");
            }
            else
            {
                w.write("Py_RETURN_NONE;\n");
            }
        };

        method_signature signature{ method };

        // convert in params from Python -> C++
        for (auto&& param : signature.params())
        {
            write_method_param_definition(w, method, param);
        }
        if (signature.params().size() > 0)
        {
            w.write("\n");
        }

        // Invoke member - simplified code path for methods w/ no out params
        if (count_out_param(signature.params()) == 0)
        {
            if (signature.return_signature())
            {
                w.register_type_namespace(signature.return_signature().Type());

                w.write("return py::convert(%%(%));\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));
            }
            else
            {
                w.write("%%(%);\n",
                    bind<write_method_invoke_context>(type, method),
                    bind<write_method_cpp_name>(method),
                    bind_list<write_param_name>(", ", signature.params()));

                write_void_return(w, method, put_property_method);
            }

            return;
        }

        // Invoke member - code path for methods w/ out params
        if (signature.return_signature())
        {
            w.register_type_namespace(signature.return_signature().Type());
            w.write("auto return_value = ");
        }
        w.write("%%(%);\n",
            bind<write_method_invoke_context>(type, method),
            bind<write_method_cpp_name>(method),
            bind_list<write_param_name>(", ", signature.params()));

        w.write("\n");

        // Convert return values and out parameters from C++ -> Python
        std::vector<std::string> return_values{};
        if (signature.return_signature() || is_constructor(method))
        {
            auto format = R"(py::pyobj_handle out_return_value{ py::convert(return_value) };
if (!out_return_value) 
{ 
    return nullptr;
}
)";
            w.write(format);
            return_values.push_back("out_return_value");
        }

        for (auto&& param : signature.params())
        {
            if (!is_out_param(param))
            {
                continue;
            }

            auto sequence = param.first.Sequence() - 1;
            auto out_param = w.write_temp("out%", sequence);

            auto format = R"(py::pyobj_handle %{ py::convert(param%) };
if (!%) 
{
    return nullptr;
}
)";
            w.write(format, out_param, sequence, out_param);
            return_values.push_back(out_param);
        }

        // Return Python projected return/out params
        if (return_values.size() == 0)
        {
            write_void_return(w, method, put_property_method);
        }
        else if (return_values.size() == 1)
        {
            w.write("return %;\n", bind<write_detach_param>(return_values[0]));
        }
        else
        {
            w.write("return %;\n", bind<write_py_tuple_pack>(return_values));
        }
    }

    void write_class_new_function(writer& w, TypeDef const& type)
    {
        w.write("\nstatic PyObject* _new_%(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept\n{\n", type.TypeName());

        {
            writer::indent_guard g{ w };

            auto constructors = get_constructors(type);
            if (is_static_class(type) || constructors.size() == 0)
            {
                w.write("py::set_invalid_activation_error(_type_name_@);\nreturn nullptr;\n", type.TypeName());
            }
            else
            {
                w.write(R"(if (kwds != nullptr)
{
    py::set_invalid_kwd_args_error();
    return nullptr;
}

Py_ssize_t arg_count = PyTuple_Size(args);
)");

                separator s{ w, "else " };
                for (auto&& ctor : constructors)
                {
                    method_signature signature{ ctor };

                    s();
                    w.write("if (arg_count == %)\n{\n", count_in_param(signature.params()));
                    {
                        writer::indent_guard g2{ w };
                        write_try_catch(w, [&](writer& w)
                        {
                            for (auto&& param : signature.params())
                            {
                                write_method_param_definition(w, ctor, param);
                            }

                            if (signature.params().size() > 0)
                            {
                                w.write("\n");
                            }

                            w.write("% instance{ % };\nreturn py::wrap(instance, type);\n",
                                type,
                                bind_list<write_param_name>(", ", signature.params()));
                        });
                    }
                    w.write("}\n");
                }

                w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
            }
        }
        w.write("}\n");
    }

    void write_new_function(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);

        if (category == category::interface_type)
        {
            auto format = R"(
static PyObject* _new_@(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
{
    py::set_invalid_activation_error(_type_name_@);
    return nullptr;
}
)";
            w.write(format, type.TypeName(), type.TypeName());
        }
        else if (category == category::class_type)
        {
            write_class_new_function(w, type);
        }
    }

    void write_method_overloads(writer& w, TypeDef const& type, std::string_view method_name)
    {
        w.write("Py_ssize_t arg_count = PyTuple_Size(args);\n\n");
        separator s{ w, "else " };

        enumerate_methods(w, type, [&](auto const& method)
        {
            if (method.Name() == method_name)
            {
                method_signature signature{ method };

                s();
                w.write("if (arg_count == %)\n{\n", count_in_param(signature.params()));
                {
                    writer::indent_guard g{ w };
                    write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, method); });
                }
                w.write("}\n");
            }
        });

        w.write(R"(else
{
    py::set_invalid_arg_count_error(arg_count);
    return nullptr;
}
)");
    }

    void write_get_property_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        w.write("\nstatic PyObject* @_%(%, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{ w };

            if (is_ptype(type))
            {
                w.write("return self->obj->%();\n", method.Name());
            }
            else
            {
                write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, method); });
            }
        }
        w.write("}\n");
    }

    void write_put_property_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        if (!method) return;

        auto return_type = is_static(method) ? "PyObject*" : "int";

        w.write("\nstatic % @_%(%, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            return_type,
            type.TypeName(),
            method.Name(),
            bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{ w };
            if (is_ptype(type))
            {
                w.write("return self->obj->%(arg);\n", method.Name());
            }
            else
            {
                if (is_static(method))
                {
                    write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, method, true); });
                }
                else
                {
                    write_setter_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, method, true); });
                }
            }
        }
        w.write("}\n");
    }

    void write_event_function(writer& w, TypeDef const& type, MethodDef const& method)
    {
        w.write("\nstatic PyObject* @_%(%, PyObject* arg) noexcept\n{\n",
            type.TypeName(), method.Name(), bind<write_method_self_param>(type, is_static(method)));
        {
            writer::indent_guard g{ w };
            if (is_ptype(type))
            {
                w.write("return self->obj->%(arg);\n", method.Name());
            }
            else
            {
                write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, method); });
            }
        }
        w.write("}\n");
    }

    void write_dunder_iter_body(writer& w, TypeDef const& type)
    {
        if (implements_iiterable(type))
        {
            write_try_catch(w, [&](writer& w) 
            { 
                w.write("return py::convert(%First());\n", bind<write_method_invoke_context>(type, MethodDef{})); 
            });
        }
        else if (implements_iiterator(type))
        {
            XLANG_ASSERT(!implements_iiterable(type));
            w.write("return reinterpret_cast<PyObject*>(%);\n",
                is_ptype(type) ? "this" : "self");
        }
        else
        {
            XLANG_ASSERT(false);
        }
    }

    void write_dunder_iter_next_body(writer& w, TypeDef const& type)
    {
        write_try_catch(w, [&](writer& w)
            {
                auto format = R"(if (%HasCurrent())
{
    auto cur = %Current();
    %MoveNext();
    return py::convert(cur);
}
else
{
    return nullptr;
})";
                w.write(format, 
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}),
                    bind<write_method_invoke_context>(type, MethodDef{}));
            }, "nullptr");
    }

    void write_seq_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(w, [&](writer& w) 
        { 
            w.write("return static_cast<Py_ssize_t>(%Size());\n", bind<write_method_invoke_context>(type, MethodDef{}));
        }, "-1");
    }

    void write_seq_item_body(writer& w, TypeDef const& type)
    {
        write_try_catch(w, [&](writer& w) 
        { 
            w.write("return py::convert(%GetAt(static_cast<uint32_t>(i)));\n", bind<write_method_invoke_context>(type, MethodDef{}));
        });
    }

    void write_seq_assign_body(writer& w, TypeDef const& type)
    {
        std::string collection_type{};
        enumerate_methods(w, type, [&](MethodDef const& method)
        {
            if (method.Name() == "GetAt")
            {
                collection_type = w.write_temp("%", method.Signature().ReturnType().Type());
            }
        });

        write_try_catch(w, [&](writer& w)
        {
            w.write(R"(if (value == nullptr) { %RemoveAt(static_cast<uint32_t>(i)); }
else { %SetAt(static_cast<uint32_t>(i), py::convert_to<%>(value)); }
return 0;
)", bind<write_method_invoke_context>(type, MethodDef{}), bind<write_method_invoke_context>(type, MethodDef{}), collection_type);
        }, "-1");
    }

    void write_map_length_body(writer& w, TypeDef const& type)
    {
        write_try_catch(w, [&](writer& w) 
        { 
            w.write("return static_cast<Py_ssize_t>(%Size());\n", bind<write_method_invoke_context>(type, MethodDef{}));
        }, "-1");
    }

    void write_map_subscript_body(writer& w, TypeDef const& type)
    {
        std::string key_type{};
        enumerate_methods(w, type, [&](MethodDef const& method)
        {
            if (method.Name() == "Lookup")
            {
                method_signature signature{ method };
                key_type = w.write_temp("%", signature.params().at(0).second->Type());
            }
        });

        write_try_catch(w, [&](writer& w) 
        { 
            w.write("return py::convert(%Lookup(py::convert_to<%>(key)));\n", bind<write_method_invoke_context>(type, MethodDef{}), key_type);
        });
    }

    void write_map_assign_body(writer& w, TypeDef const& type)
    {
        std::string key_type, value_type{};
        enumerate_methods(w, type, [&](MethodDef const& method)
        {
            if (method.Name() == "Lookup")
            {
                method_signature signature{ method };
                key_type = w.write_temp("%", signature.params().at(0).second->Type());
                value_type = w.write_temp("%", signature.return_signature().Type());
            }
        });

        write_try_catch(w,
            [&](writer& w)
        {
            auto format = R"(auto _key = py::convert_to<%>(key);
if (value == nullptr) { %Remove(_key); }
else { %Insert(_key, py::convert_to<%>(value)); }
return 0;
)";
            w.write(format, key_type, bind<write_method_invoke_context>(type, MethodDef{}), bind<write_method_invoke_context>(type, MethodDef{}), value_type);
        }, "-1");
    }
    
    void write_method_functions(writer& w, TypeDef const& type)
    {
        // create a map of methods to determine overloads + ensure all overloads match instance/static 
        std::map<std::string_view, bool> method_map{};
        enumerate_methods(w, type, [&](auto const& method)
        {
            XLANG_ASSERT(contains(method_map, method.Name()) ? method_map[method.Name()] == is_static(method) : true);
            method_map[method.Name()] = is_static(method);
        });

        for (auto&&[method_name, method_is_static] : method_map)
        {
            w.write("\nstatic PyObject* @_%(%, PyObject* args) noexcept\n{\n",
                type.TypeName(),
                method_name,
                bind<write_method_self_param>(type, method_is_static));
            {
                writer::indent_guard g{ w };

                if (is_ptype(type))
                {
                    w.write("return self->obj->%(args);\n", method_name);
                }
                else
                {
                    write_method_overloads(w, type, method_name);
                }
            }
            w.write("}\n");
        }

        enumerate_properties(w, type, [&](auto const& prop)
        {
            auto&&[get_method, put_method] = get_property_methods(prop);
            write_get_property_function(w, type, get_method);
            write_put_property_function(w, type, put_method);
        });

        enumerate_events(w, type, [&](auto const& evt)
        {
            auto&&[add_method, remove_method] = get_event_methods(evt);
            write_event_function(w, type, add_method);
            write_event_function(w, type, remove_method);
        });

        if (!(is_ptype(type) || is_static_class(type)))
        {
            w.write("\nstatic PyObject* _from_@(PyObject* /*unused*/, PyObject* arg) noexcept\n{\n", type.TypeName());
            {
                writer::indent_guard g{ w };
                write_try_catch(w, [&](writer& w)
                {
                    auto format = "auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);\nreturn py::convert(return_value.as<%>());\n";
                    w.write(format, type);
                });
            }
            w.write("}\n");
        }

        if (implements_iclosable(type))
        {
            w.write(strings::enter_function, type.TypeName(), bind<write_pywrapper_type>(type));

            w.write("\nstatic PyObject* _exit_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{ w };
                write_try_catch(w, [](auto& w) { w.write("self->obj.Close();\nPy_RETURN_FALSE;\n"); });
            }
            w.write("}\n");
        }

        if (implements_istringable(type))
        {
            w.write("\nstatic PyObject* _str_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                writer::indent_guard g{ w };
                write_try_catch(w, [](auto& w) { w.write("return py::convert(self->obj.ToString());\n"); });
            }
            w.write("}\n");
        }

        auto write_ptype_body = [&](std::string_view ptype_func_call, std::function<void(writer&)> ctype_func)
        {
            writer::indent_guard g{ w };

            if (is_ptype(type))
            {
                w.write("return self->obj->%;\n", ptype_func_call);
            }
            else
            {
                ctype_func(w);
            }
        };

        if (implements_iasync(type))
        {
            w.write("\nstatic PyObject* _await_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("dunder_await()", [&](auto& w) { w.write("return py::dunder_await(self->obj);\n"); });
            }
            w.write("}\n");
        }

        if (implements_iiterable(type) || implements_iiterator(type))
        {
            w.write("\nstatic PyObject* _iterator_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("dunder_iter()", [&](auto& w) { write_dunder_iter_body(w, type); });
            }
            w.write("}\n");
        }

        if (implements_iiterator(type))
        {
            w.write("\nstatic PyObject* _iterator_next_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("dunder_iternext()", [&](auto& w) { write_dunder_iter_next_body(w, type); });
            }
            w.write("}\n");
        }

        if (implements_sequence(type))
        {
            w.write("\nstatic Py_ssize_t _seq_length_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("seq_length()", [&](auto& w) { write_seq_length_body(w, type); });
            }
            w.write("}\n");

            w.write("\nstatic PyObject* _seq_item_@(%* self, Py_ssize_t i) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("seq_item(i)", [&](auto& w) { write_seq_item_body(w, type); });
            }
            w.write("}\n");

            if (implements_ivector(type))
            {
                w.write("\nstatic int _seq_assign_@(%* self, Py_ssize_t i, PyObject* value) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
                {
                    write_ptype_body("seq_assign(i, value)", [&](auto& w) { write_seq_assign_body(w, type); });
                }
                w.write("}\n");
            }
        }

        if (implements_mapping(type))
        {
            w.write("\nstatic Py_ssize_t _map_length_@(%* self) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("map_length()", [&](auto& w) { write_map_length_body(w, type); });
            }
            w.write("}\n");

            w.write("\nstatic PyObject* _map_subscript_@(%* self, PyObject* key) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
            {
                write_ptype_body("map_subscript(key)", [&](auto& w) { write_map_subscript_body(w, type); });
            }
            w.write("}\n");

            if (implements_imap(type))
            {
                w.write("\nstatic int _map_assign_@(%* self, PyObject* key, PyObject* value) noexcept\n{\n", type.TypeName(), bind<write_pywrapper_type>(type));
                {
                    write_ptype_body("map_assign(key, value)", [&](auto& w) { write_map_assign_body(w, type); });
                }
                w.write("}\n");
            }
        }
    }

    void write_method_table(writer& w, TypeDef const& type)
    {
        auto get_argument_convention_flag = [](MethodDef const& method)
        {
            switch (get_argument_convention(method))
            {
            case argument_convention::no_args:
                return "METH_NOARGS";
            case argument_convention::single_arg:
                return "METH_O";
            case argument_convention::variable_args:
                return "METH_VARARGS";
            }

            throw_invalid("invalid argument_convention");
        };

        auto write_row = [&](MethodDef const& method)
        {
            auto argument_convention_flag = get_argument_convention_flag(method);
            auto static_flag = is_static(method) || is_constructor(method)
                ? " | METH_STATIC"
                : "";

            w.write("{ \"%\", (PyCFunction)@_%, %%, nullptr },\n",
                bind<write_lower_snake_case>(method.Name()),
                type.TypeName(), method.Name(),
                argument_convention_flag,
                static_flag);
        };

        w.write("\nstatic PyMethodDef _methods_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            std::set<std::string_view> method_names{};
            enumerate_methods(w, type, [&](auto const& method)
            {
                if (!contains(method_names, method.Name()))
                {
                    write_row(method);
                }

                method_names.insert(method.Name());
            });

            enumerate_properties(w, type, [&](auto const& prop)
            {
                auto[get_method, put_method] = get_property_methods(prop);
                // instance properties are listed in the getset table, not the method table
                if (is_static(get_method))
                {
                    write_row(get_method);
                    if (put_method)
                    {
                        write_row(put_method);
                    }
                }
            });

            enumerate_events(w, type, [&](auto const& evt)
            {
                auto[add_method, remove_method] = get_event_methods(evt);
                write_row(add_method);
                write_row(remove_method);
            });

            // TODO: support _from for ptypes
            if (!(is_ptype(type) || is_static_class(type)))
            {
                w.write("{ \"_from\", (PyCFunction)_from_@, METH_O | METH_STATIC, nullptr },\n", type.TypeName());
            }

            if (implements_iclosable(type))
            {
                w.write("{ \"__enter__\", (PyCFunction)_enter_@, METH_O, nullptr },\n", type.TypeName());
                w.write("{ \"__exit__\",  (PyCFunction)_exit_@,  METH_O, nullptr },\n", type.TypeName());
            }

            w.write("{ nullptr }\n");
        }

        w.write("};\n");
    }

    void write_getset_table(writer& w, TypeDef const& type)
    {
        auto write_row = [&](std::string_view field_name, std::string_view getter_name, std::string_view setter_name)
        {
            auto setter = setter_name.empty() ? "nullptr" : w.write_temp("(setter)@_%", type.TypeName(), setter_name);

            // TODO: remove const_cast once pywinrt is updated to target Python 3.7. 
            //       pywinrt currently targeting 3.6 because that's the version that ships with VS 2017 v15.8
            //       https://github.com/python/cpython/commit/007d7ff73f4e6e65cfafd512f9c23f7b7119b803
            w.write("{ const_cast<char*>(\"%\"), (getter)@_%, %, nullptr, nullptr },\n",
                bind<write_lower_snake_case>(field_name),
                type.TypeName(), getter_name,
                setter);
        };

        w.write("\nstatic PyGetSetDef _getset_@[] = {\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            auto category = get_category(type);
            if (category == category::struct_type)
            {
                for (auto&& field : type.FieldList())
                {
                    write_row(field.Name(), w.write_temp("get_%", field.Name()), w.write_temp("set_%", field.Name()));
                }
            }
            else if (category == category::class_type || category == category::interface_type)
            {
                enumerate_properties(w, type, [&](Property prop)
                {
                    auto[getter, setter] = get_property_methods(prop);

                    // static properties are listed in the method table, not the getset table
                    if (!is_static(getter))
                    {
                        write_row(prop.Name(), getter.Name(), setter ? setter.Name() : "");
                    }
                });
            }
            w.write("{ nullptr }\n");
        }
        w.write("};\n");
    }

    void write_type_slot_table(writer& w, TypeDef const& type)
    {
        auto category = get_category(type);
        auto name = type.TypeName();

        w.write("\nstatic PyType_Slot _type_slots_@[] = \n{\n", name);

        {
            writer::indent_guard g{ w };

            w.write("{ Py_tp_new, _new_@ },\n", name);
            if (!is_static_class(type))
            {
                w.write("{ Py_tp_dealloc, _dealloc_@ },\n", name);
            }
            if ((category == category::class_type) || (category == category::interface_type))
            {
                w.write("{ Py_tp_methods, _methods_@ },\n", name);
            }
            w.write("{ Py_tp_getset, _getset_@ },\n", name);
            if (implements_istringable(type))
            {
                w.write("{ Py_tp_str, _str_@ },\n", name);
            }
            if (implements_iasync(type))
            {
                w.write("{ Py_am_await, (unaryfunc)_await_@ },\n", name);
            }
            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("{ Py_tp_iter, _iterator_@ },\n", name);
            }
            if (implements_iiterator(type))
            {
                w.write("{ Py_tp_iternext, _iterator_next_@ },\n", name);
            }
            if (implements_sequence(type))
            {
                w.write("{ Py_sq_length, _seq_length_@ },\n", name);
                w.write("{ Py_sq_item, _seq_item_@ },\n", name);

                if (implements_ivector(type))
                {
                    w.write("{ Py_sq_ass_item, _seq_assign_@ },\n", name);
                }
            }
            if (implements_mapping(type))
            {
                w.write("{ Py_mp_length, _map_length_@ },\n", name);
                w.write("{ Py_mp_subscript, _map_subscript_@ },\n", name);

                if (implements_imap(type))
                {
                    w.write("{ Py_mp_ass_subscript, _map_assign_@ },\n", name);
                }
            }
            w.write("{ 0, nullptr },\n");
        }
        w.write("};\n");
    }

    void write_type_spec(writer& w, TypeDef const& type)
    {
        auto type_size = is_static_class(type) ? "0" : w.write_temp("sizeof(%)", bind<write_pywrapper_type>(type));

        auto format = R"(
static PyType_Spec _type_spec_@ =
{
    "%.@",
    %,
    0,
    Py_TPFLAGS_DEFAULT,
    _type_slots_@
};
)";
        auto type_name = type.TypeName();
        w.write(format,
            type_name,
            bind<write_ns_module_name>(type.TypeNamespace()),
            type_name,
            type_size,
            type_name);
    }

    void write_category(writer& w, TypeDef const& type)
    {
        switch (get_category(type))
        {
        case category::class_type:
            w.write("class");
            break;
        case category::delegate_type:
            w.write("delegate");
            break;
        case category::enum_type:
            w.write("enum");
            break;
        case category::interface_type:
            w.write("interface");
            break;
        case category::struct_type:
            w.write("struct");
            break;
        }
    }

    void write_inspectable_type(writer& w, TypeDef const& type)
    {
        if (is_exclusive_to(type)) return;

        auto guard{ w.push_generic_params(type.GenericParam()) };
        
        w.write("\n// ----- @ % --------------------\n", type.TypeName(), bind<write_category>(type));
        write_winrt_type_name_constant(w, type);
        write_new_function(w, type);
        write_dealloc_function(w, type);
        write_method_functions(w, type);
        write_method_table(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma region pinterface functions
    void write_pinterface_type_mapper(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto format = R"(template <%>
struct pinterface_python_type<%<%>>
{
    using abstract = %;
    using concrete = %<%>;
};

)";
        w.write(format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind_list<write_template_arg_name>(", ", type.GenericParam()),
            bind<write_pyproj_type>(type),
            bind<write_pyimpl_type>(type),
            bind_list<write_template_arg_name>(", ", type.GenericParam()));
    }

    void write_pinterface_decl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            w.write("virtual ~@() {};\n", type.TypeName());
            w.write("virtual winrt::Windows::Foundation::IUnknown const& get_unknown() noexcept = 0;\n");
            w.write("virtual std::size_t hash() noexcept = 0;\n");

            std::set<std::string_view> method_names{};
            enumerate_methods(w, type, [&](auto const& method)
            {
                if (!contains(method_names, method.Name()))
                {
                    w.write("virtual PyObject* %(PyObject*) noexcept = 0;\n", method.Name());
                }

                method_names.insert(method.Name());
            });

            enumerate_properties(w, type, [&](auto const& prop)
            {
                auto[get_method, put_method] = get_property_methods(prop);
                w.write("virtual PyObject* %() noexcept = 0;\n", get_method.Name());
                if (put_method)
                {
                    w.write("virtual int %(PyObject*) noexcept = 0;\n", put_method.Name());
                }
            });

            enumerate_events(w, type, [&](auto const& evt)
            {
                auto[add_method, remove_method] = get_event_methods(evt);
                w.write("virtual PyObject* %(PyObject*) noexcept = 0;\n", add_method.Name());
                w.write("virtual PyObject* %(PyObject*) noexcept = 0;\n", remove_method.Name());
            });

            if (implements_iasync(type))
            {
                w.write("virtual PyObject* dunder_await() noexcept = 0;\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iter() noexcept = 0;\n");
            }

            if (implements_iiterator(type))
            {
                w.write("virtual PyObject* dunder_iternext() noexcept = 0;\n");
            }

            if (implements_sequence(type))
            {
                w.write("virtual Py_ssize_t seq_length() noexcept = 0;\n");
                w.write("virtual PyObject* seq_item(Py_ssize_t i) noexcept = 0;\n");

                if (implements_ivector(type))
                {
                    w.write("virtual int seq_assign(Py_ssize_t i, PyObject* value) noexcept = 0;\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("virtual Py_ssize_t map_length() noexcept = 0;\n");
                w.write("virtual PyObject* map_subscript(PyObject* key) noexcept = 0;\n");

                if (implements_imap(type))
                {
                    w.write("virtual int map_assign(PyObject* key, PyObject* value) noexcept = 0;\n");
                }
            }
        }
        w.write("};\n");
    }

    void write_pinterface_impl(writer& w, TypeDef const& type)
    {
        if (!is_ptype(type))
            return;

        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\ntemplate<%>\nstruct @ : public py::proj::%::@\n{\n",
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type.TypeName(),
            bind<write_type_namespace>(type),
            type.TypeName());

        {
            writer::indent_guard g{ w };

            w.write("@(%<%> o) : _obj(o) {}\n", type.TypeName(), type, bind_list<write_template_arg_name>(", ", type.GenericParam()));
            w.write("winrt::Windows::Foundation::IUnknown const& get_unknown() noexcept override { return _obj; }\n");
            w.write("std::size_t hash() noexcept override { return py::get_instance_hash(_obj); }\n");

            std::set<std::string_view> method_names{};
            enumerate_methods(w, type, [&](auto const& method)
            {
                method_names.insert(method.Name());
            });

            for (auto&& method_name : method_names)
            {
                w.write("PyObject* %(PyObject* args) noexcept override\n{\n", method_name);
                {
                    writer::indent_guard gg{ w };
                    write_method_overloads(w, type, method_name);
                }
                w.write("}\n");
            }

            enumerate_properties(w, type, [&](auto const& prop)
            {
                auto methods = get_property_methods(prop);
                auto get_method = std::get<0>(methods);
                auto put_method = std::get<1>(methods);

                w.write("PyObject* %() noexcept override\n{\n", get_method.Name());
                {
                    writer::indent_guard gg{ w };
                    write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, get_method); });
                }
                w.write("}\n");

                if (put_method)
                {
                    w.write("int %(PyObject* arg) noexcept override\n{\n", put_method.Name());
                    {
                        writer::indent_guard gg{ w };
                        write_setter_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, put_method, true); });
                    }
                    w.write("}\n");

                }
            });

            enumerate_events(w, type, [&](auto const& evt)
            {
                auto methods = get_event_methods(evt);
                auto add_method = std::get<0>(methods);
                auto remove_method = std::get<1>(methods);

                w.write("PyObject* %(PyObject* arg) noexcept override\n{\n", add_method.Name());
                {
                    writer::indent_guard gg{ w };
                    write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, add_method); });
                }
                w.write("}\n");

                w.write("PyObject* %(PyObject* arg) noexcept override\n{\n", remove_method.Name());
                {
                    writer::indent_guard gg{ w };
                    write_try_catch(w, [&](writer& w) { write_method_body_contents(w, type, remove_method); });
                }
                w.write("}\n");
            });

            if (implements_iasync(type))
            {
                w.write("PyObject* dunder_await() noexcept override { return py::dunder_await(_obj); }\n");
            }

            if (implements_iiterable(type) || implements_iiterator(type))
            {
                w.write("PyObject* dunder_iter() noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_dunder_iter_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_iiterator(type))
            {
                w.write("PyObject* dunder_iternext() noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_dunder_iter_next_body(w, type);
                }
                w.write("}\n");
            }

            if (implements_sequence(type))
            {
                w.write("Py_ssize_t seq_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_seq_length_body(w, type);
                }
                w.write("}\n");

                w.write("PyObject* seq_item(Py_ssize_t i) noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_seq_item_body(w, type);
                }
                w.write("}\n");

                if (implements_ivector(type))
                {
                    w.write("int seq_assign(Py_ssize_t i, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{ w };
                        write_seq_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            if (implements_mapping(type))
            {
                w.write("Py_ssize_t map_length() noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_map_length_body(w, type);
                }
                w.write("}\n");

                w.write("PyObject* map_subscript(PyObject* key) noexcept override\n{\n");
                {
                    writer::indent_guard gg{ w };
                    write_map_subscript_body(w, type);
                }
                w.write("}\n");

                if (implements_imap(type))
                {
                    w.write("int map_assign(PyObject* key, PyObject* value) noexcept override\n{\n");
                    {
                        writer::indent_guard gg{ w };
                        write_map_assign_body(w, type);
                    }
                    w.write("}\n");
                }
            }

            w.write("\n%<%> _obj{ nullptr };\n", type, bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
        w.write("};\n");
    }
#pragma endregion

#pragma region struct functions

    void write_struct_converter_decl(writer& w, TypeDef const& type)
    {
        auto ns = type.TypeNamespace();
        auto name = type.TypeName();
        if ((ns == "Windows.Foundation") && (name == "EventRegistrationToken"))
        {
            // The declaration for event_token is baked into pybase.h to address ordering issues.
            return;
        }
        
        w.write("template<>\nstruct converter<%>\n{\n", type);
        {
            writer::indent_guard g{ w };
            w.write("static PyObject* convert(% instance) noexcept;\nstatic % convert_to(PyObject* obj);\n", type, type);
        }

        w.write("};\n\n");
    }

    void write_struct_field_var_type(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type type)
        {
            switch (type)
            {
            case fundamental_type::Boolean:
                w.write("bool");
                break;
            case fundamental_type::Char:
                w.write("char16_t");
                break;
            case fundamental_type::Int8:
                w.write("int8_t");
                break;
            case fundamental_type::UInt8:
                w.write("uint8_t");
                break;
            case fundamental_type::Int16:
                w.write("int16_t");
                break;
            case fundamental_type::UInt16:
                w.write("uint16_t");
                break;
            case fundamental_type::Int32:
                w.write("int32_t");
                break;
            case fundamental_type::UInt32:
                w.write("uint32_t");
                break;
            case fundamental_type::Int64:
                w.write("int64_t");
                break;
            case fundamental_type::UInt64:
                w.write("uint64_t");
                break;
            case fundamental_type::Float:
                w.write("float");
                break;
            case fundamental_type::Double:
                w.write("double");
                break;
            case fundamental_type::String:
                w.write("winrt::hstring");
                break;
            default:
                throw_invalid("invalid fundamental type");
            }
        },
            [&]([[maybe_unused]] TypeDef const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write("py::pyobj_handle");
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_keyword(writer& w, Field const& field)
    {
        w.write("\"%\", ", bind<write_lower_snake_case>(field.Name()));
    }

    void write_struct_field_format(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type type)
        {
            switch (type)
            {
            case fundamental_type::Boolean:
                w.write("p");
                break;
                // TODO: 'u' format string was deprecated in Python 3.3. Need to move to a supported construct
            case fundamental_type::Char:
                w.write("u1");
                break;
            case fundamental_type::Int8:
                w.write("y1");
                break;
            case fundamental_type::UInt8:
                w.write("y1");
                break;
            case fundamental_type::Int16:
                w.write("h");
                break;
            case fundamental_type::UInt16:
                w.write("H");
                break;
            case fundamental_type::Int32:
                w.write("i");
                break;
            case fundamental_type::UInt32:
                w.write("I");
                break;
            case fundamental_type::Int64:
                w.write("L");
                break;
            case fundamental_type::UInt64:
                w.write("K");
                break;
            case fundamental_type::Float:
                w.write("f");
                break;
            case fundamental_type::Double:
                w.write("d");
                break;
                // TODO: 'u' format string was deprecated in Python 3.3. Need to move to a supported construct
            case fundamental_type::String:
                w.write("u");
                break;
            default:
                throw_invalid("invalid fundamental type");
            }
        },
            [&]([[maybe_unused]] type_definition const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write("O");
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_parse_parameter(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type) { w.write(", &_%", field.Name()); },
            [&]([[maybe_unused]] type_definition const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write(", _%.put()", field.Name());
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_initalizer(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, false),
            [&](fundamental_type) { w.write("_%", field.Name()); },
            [&](type_definition const& type)
        {
            auto category = get_category(type);
            XLANG_ASSERT((category == category::struct_type) || (category == category::enum_type));
            switch (category)
            {
            case category::enum_type:
                w.write("static_cast<%>(_%)", type, field.Name());
                break;
            case category::struct_type:
                w.write("py::converter<%>::convert_to(_%.get())", type, field.Name());
                break;
            }
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_field_ref_capture(writer& w, Field const& field)
    {
        call(get_struct_field_semantics(field, true),
            [&](fundamental_type) {},
            [&]([[maybe_unused]] TypeDef const& type)
        {
            XLANG_ASSERT(get_category(type) == category::struct_type);
            w.write(", &_%", field.Name());
        },
            [](auto) { throw_invalid("invalid struct field type"); });
    }

    void write_struct_constructor(writer& w, TypeDef const& type)
    {
        w.write("\nPyObject* _new_@(PyTypeObject* type, PyObject* args, PyObject* kwds)\n{", type.TypeName());
        {
            writer::indent_guard g{ w };
            w.write(R"(
auto tuple_size = PyTuple_Size(args);

if ((tuple_size == 0) && (kwds == nullptr))
{
)");
            {
                writer::indent_guard gg{ w };
                write_try_catch(w, [&](writer& w) { w.write("% return_value{};\nreturn py::convert(return_value);\n", type); });
            }
            w.write(R"(}

if ((tuple_size == 1) && (kwds == nullptr))
{
)");
            {
                writer::indent_guard gg{ w };
                w.write(R"(auto arg = PyTuple_GetItem(args, 0);
if (PyDict_Check(arg))
{
)");
                {
                    writer::indent_guard ggg{ w };
                    write_try_catch(w, [&](writer& w) { w.write("auto return_value = py::convert_to<%>(arg);\nreturn py::convert(return_value);\n", type); });
                }
                w.write("}\n");
            }
            w.write("}\n\n");

            for (auto&& field : type.FieldList())
            {
                w.write("% _%{};\n", bind<write_struct_field_var_type>(field), field.Name());
            }

            {
                auto format = R"(
static const char* kwlist[] = {%nullptr};
if (!PyArg_ParseTupleAndKeywords(args, kwds, "%", const_cast<char**>(kwlist)%))
{
    return nullptr;
}

)";
                w.write(format,
                    bind_each<write_struct_field_keyword>(type.FieldList()),
                    bind_each<write_struct_field_format>(type.FieldList()),
                    bind_each<write_struct_field_parse_parameter>(type.FieldList()));
            }

            if (has_custom_conversion(type))
            {
                auto format = "% return_value{ };\ncustom_set(return_value, %);\nreturn py::convert(return_value);\n";
                write_try_catch(w, [&](writer& w) { w.write(format, type, bind<write_struct_field_initalizer>(type.FieldList().first)); });
            }
            else
            {
                auto ref_captures = w.write_temp("%", bind_each<write_struct_field_ref_capture>(type.FieldList()));
                auto format = "% return_value{ % };\nreturn py::convert(return_value);\n";
                write_try_catch(w,
                    [&](writer& w) { w.write(format, type, bind_list<write_struct_field_initalizer>(", ", type.FieldList())); },
                    "nullptr");
            }
        }
        w.write("}\n");
    }

    void write_struct_field_name(writer& w, Field const& field)
    {
        static const std::set<std::string_view> custom_numerics = { "Matrix3x2", "Matrix4x4", "Plane", "Quaternion", "Vector2", "Vector3", "Vector4" };

        auto type = field.Parent();
        if ((type.TypeNamespace() == "Windows.Foundation.Numerics") &&
            (custom_numerics.find(type.TypeName()) != custom_numerics.end()))
        {
            for (char c : field.Name())
            {
                w.write(static_cast<char>(::tolower(c)));
            }
        }
        else
        {
            w.write(field.Name());
        }
    }

    void write_struct_getset_function(writer& w, TypeDef const& type, Field const& field)
    {
        w.write("\nstatic PyObject* @_get_%(%* self, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{ w };

            if (has_custom_conversion(type))
            {
                write_try_catch(w, [](writer& w) { w.write("return py::convert(custom_get(self->obj));\n"); });
            }
            else
            {
                write_try_catch(w, [&](writer& w) { w.write("return py::convert(self->obj.%);\n", bind<write_struct_field_name>(field)); });
            }
        }
        w.write("}\n");

        w.write("\nstatic int @_set_%(%* self, PyObject* arg, void* /*unused*/) noexcept\n{\n",
            type.TypeName(),
            field.Name(),
            bind<write_pywrapper_type>(type));
        {
            writer::indent_guard g{ w };

            if (has_custom_conversion(type))
            {
                write_setter_try_catch(w, [&](writer& w)
                {
                    w.write("custom_set(self->obj, py::converter<%>::convert_to(arg));\nreturn 0;\n", field.Signature().Type());
                });
            }
            else
            {
                write_setter_try_catch(w, [&](writer& w)
                {
                    w.write("self->obj.% = py::converter<%>::convert_to(arg);\nreturn 0;\n",
                        bind<write_struct_field_name>(field),
                        field.Signature().Type());
                });
            }
        }
        w.write("}\n");
    }

    void write_struct_getset_functions(writer& w, TypeDef const& type)
    {
        for (auto&& field : type.FieldList())
        {
            write_struct_getset_function(w, type, field);
        }
    }

    void write_struct_convert_functions(writer& w, TypeDef const& type)
    {
        w.write("\n\nPyObject* py::converter<%>::convert(% instance) noexcept\n{\n", type, type);
        {
            writer::indent_guard g{ w };
            w.write("return py::wrap_struct(instance, py::get_python_type<%>());\n", type);
        }
        w.write("}\n");

        w.write("% py::converter<%>::convert_to(PyObject* obj)\n{\n", type, type);
        {
            writer::indent_guard g{ w };

            auto format = R"(throw_if_pyobj_null(obj);
    
if (Py_TYPE(obj) == py::get_python_type<%>())
{
    return reinterpret_cast<py::winrt_struct_wrapper<%>*>(obj)->obj;
}
    
if (!PyDict_Check(obj))
{
    throw winrt::hresult_invalid_argument();
}
    
)";
            w.write(format, type, type);

            w.write("% return_value{};\n", type);

            for (auto&& field : type.FieldList())
            {
                w.write("\npy::pyobj_handle py_%{ PyDict_GetItemString(obj, \"%\") };\n", field.Name(), bind<write_lower_snake_case>(field.Name()));
                w.write("if (!py_%) { throw winrt::hresult_invalid_argument(); }\n", field.Name());

                if (has_custom_conversion(type))
                {
                    w.write("custom_set(return_value, converter<%>::convert_to(py_%.get()));\n", field.Signature().Type(), field.Name());
                }
                else
                {
                    w.write("return_value.% = converter<%>::convert_to(py_%.get());\n", bind<write_struct_field_name>(field), field.Signature().Type(), field.Name());
                }
            }

            w.write("\nreturn return_value;\n");
        }
        w.write("}");
    }

    void write_struct(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        w.write("\n// ----- % struct --------------------\n", type.TypeName());
        write_winrt_type_name_constant(w, type);
        write_struct_constructor(w, type);
        write_dealloc_function(w, type);
        write_struct_getset_functions(w, type);
        write_getset_table(w, type);
        write_type_slot_table(w, type);
        write_type_spec(w, type);
    }

#pragma endregion

#pragma region delegate functions
    void write_delegate_template_args(writer& w, TypeDef const& type)
    {
        if (is_ptype(type))
        {
            w.write("<%>", bind_list<write_template_arg_name>(", ", type.GenericParam()));
        }
    }

    void write_delegate_type_mapper(writer& w, TypeDef const& type)
    {
        auto format = R"(template <%>
struct delegate_python_type<%%>
{
    using type = %%;
};

)";
        w.write(format,
            bind_list<write_template_arg>(", ", type.GenericParam()),
            type,
            bind<write_delegate_template_args>(type),
            bind<write_pyimpl_type>(type),
            bind<write_delegate_template_args>(type));
    }

    void write_delegate_param(writer& w, method_signature::param_t const& p)
    {
        w.write("auto %", bind<write_param_name>(p));
    }

    void write_delegate_callable_wrapper(writer& w, TypeDef const& type)
    {
        auto guard{ w.push_generic_params(type.GenericParam()) };

        auto invoke = get_delegate_invoke(type);
        method_signature signature{ invoke };

        if (is_ptype(type))
        {
            w.write("\ntemplate <%>", bind_list<write_template_arg>(", ", type.GenericParam()));
        }

        w.write("\nstruct @\n{\n", type.TypeName());
        {
            writer::indent_guard g{ w };

            w.write("static %% get(PyObject* callable)\n{\n", type, bind<write_delegate_template_args>(type));
            {
                writer::indent_guard gg{ w };

                {
                    auto format = R"(py::delegate_callable _delegate{ callable };
    
return [delegate = std::move(_delegate)](%)
{
)";
                    w.write(format, bind_list<write_delegate_param>(", ", signature.params()));
                }
                {
                    writer::indent_guard ggg{ w };

                    w.write("winrt::handle_type<py::gil_state_traits> gil_state{ PyGILState_Ensure() };\n\n");

                    std::vector<std::string> tuple_params{};
                    for (auto&& p : signature.params())
                    {
                        auto param_name = w.write_temp("%", bind<write_param_name>(p));
                        auto py_param_name = "py_"s + param_name;

                        w.write("py::pyobj_handle %{ py::convert(%) };\n", py_param_name, param_name);
                        tuple_params.push_back(py_param_name);
                    }

                    if (tuple_params.size() > 0)
                    {
                        w.write("\npy::pyobj_handle args{ % };\n", bind<write_py_tuple_pack>(tuple_params));
                    }
                    else
                    {
                        w.write("py::pyobj_handle args{ nullptr };\n");
                    }

                    w.write(R"(py::pyobj_handle return_value{ PyObject_CallObject(delegate.callable(), args.get()) };

if (!return_value) 
{
    // TODO: propagate Python error
    throw winrt::hresult_invalid_argument();
}
)");

                    if (signature.return_signature())
                    {
                        w.write("\nreturn py::convert<%>(return_value.get());\n", signature.return_signature().Type());
                    }
                }

                w.write("};\n");
            }
            w.write("};\n");
        }
        w.write("};\n");
    }
#pragma endregion
}